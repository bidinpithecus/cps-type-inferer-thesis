\chapter{Teoria de Tipos} \label{ch:type-theory}

% Introdução Teoria de Tipos (Paradoxo de Russel)
A Teoria de Tipos, conforme apresentada por \cite{COQUAND2022}, foi introduzida por Russell em 1908 ao encontrar um paradoxo na Teoria de Conjuntos, conhecido atualmente como o Paradoxo de Russell:

% Definição do paradoxo
\begin{equation} \label{eq:russell-paradox}
  \text{Seja } R = \{ x \mid x \notin x \}, \text{ então } R \in R \iff R \notin R
\end{equation}

% Explicação da definição
Ou seja, considere $R$ como o conjunto dos conjuntos que não contêm a si mesmos.
A contradição surge ao observar que, se o conjunto $R$ contém a si mesmo, isso implica que $R$ não contém a si mesmo, e vice-versa.

% Paradoxo do barbeiro
Outra maneira de descrever esse paradoxo é através do Paradoxo do Barbeiro: imagine uma cidade com apenas um barbeiro, onde ele somente barbeia aqueles que não se barbeiam.
O paradoxo surge quando perguntamos: ``Quem barbeia o barbeiro?''.
Ele não pode fazer sua própria barba, pois barbeia apenas aqueles que não fazem a própria barba.
No entanto, se ele não faz sua própria barba, então pertence ao grupo daqueles que devem ser barbeados pelo barbeiro, logo, ele deveria barbear-se.
Essa situação gera uma contradição semelhante ao Paradoxo de Russell.

% Utilidade Teoria de Tipos
Atualmente, a principal aplicação da Teoria de Tipos está na formalização de sistemas de tipos para linguagens de programação.
Ela tem diversas utilidades, como em assistentes de prova que utilizam sistemas de tipos para codificar provas.
Por exemplo, o Coq \cite{COQUAND1998} utiliza o Cálculo de Construções.
Além disso, a Teoria de Tipos é fundamental em algoritmos de checagem de tipos, que fazem parte da análise semântica em compiladores, bem como na inferência de tipos em linguagens de programação, como o Cálculo Lambda Simplesmente Tipado.

% Introduzir conceitos de tipos simples, tipos dependentes e tipos polimórficos:
No contexto das linguagens de programação, podemos distinguir três categorias principais de tipos: tipos simples, tipos polimórficos e tipos dependentes \cite{PIERCE2002}.
Tipos simples atribuem um tipo fixo a cada termo, enquanto tipos polimórficos introduzem a noção de generalidade, permitindo que funções possam ser aplicadas a argumentos de diferentes tipos sem a necessidade de serem redefinidas para cada um.
Já os tipos dependentes permitem que tipos dependam de valores.

% Exemplo 1: Tipos Simples
Um exemplo de tipo simples é uma função que opera sobre números inteiros.
Esta função recebe um número inteiro e retorna outro número inteiro.
Seu tipo, portanto, é representado como $Int \rightarrow Int$, indicando que tanto a entrada quanto a saída são do tipo inteiro.

% Exemplo 2: Tipos Polimórficos
Um exemplo de polimorfismo é a função identidade, que recebe um elemento de qualquer tipo e retorna o mesmo elemento.
Seu tipo é expresso como $a \rightarrow a$, onde $a$ pode ser qualquer tipo.
Este tipo polimórfico indica que a função identidade pode ser usada com diferentes tipos de dados sem precisar ser modificada.

% Exemplo 3: Tipos Dependentes
Em linguagens com suporte a tipos dependentes, um exemplo seria o de um vetor cujo comprimento (número de elementos) faz parte de seu tipo.
Nesse caso, uma função de concatenação de vetores deve garantir que somente vetores com tipos compatíveis em relação ao comprimento possam ser concatenados.
O tipo da função de concatenação seria algo como\footnote{A notação exata pode variar entre diferentes linguagens de programação que suportam tipos dependentes. A estrutura apresentada serve apenas como uma ilustração conceitual do comportamento esperado.} $Vector(n) \rightarrow Vector(m) \rightarrow Vector(n+m)$, onde $n$ e $m$ são valores que representam os comprimentos dos vetores e fazem parte da definição de tipo.

% Especificar como polimorfismo se relaciona com a inferência de tipos:
O polimorfismo desempenha um papel crucial na inferência de tipos.
Em linguagens com suporte a inferência de tipos, como Haskell, o sistema de tipos é capaz de deduzir tanto tipos específicos quanto tipos genéricos, sempre que possível, para permitir polimorfismo \cite{PIERCE2002}.
O polimorfismo refere-se à capacidade de uma função ou expressão operar sobre diferentes tipos de dados de forma genérica.
Um exemplo clássico é a função identidade, $\lambda x.x$, que pode ser tipada como $\forall \alpha. \alpha \to \alpha$, indicando que a função aceita um valor de qualquer tipo $\alpha$ e retorna um valor do mesmo tipo.
Esse tipo é conhecido como polimorfismo universal \cite{PIERCE2002}.

Já a função de soma apresentada na Figura \ref{code:add} demonstra outro tipo de polimorfismo.
Como possui tipagem explícita $Int \rightarrow Int \rightarrow Int$, apenas valores do tipo inteiro podem ser somados.
No entanto, essa mesma função pode ser generalizada para permitir a soma de quaisquer números, contanto que sejam do mesmo tipo.
Aqui entra o conceito de restrição de classe de tipos.

Em Haskell, uma classe de tipos é um conjunto de tipos que compartilham um conjunto comum de operações.
A classe \texttt{Num}, por exemplo, é a classe de tipos que suportam operações numéricas, como adição e multiplicação.
Quando o tipo de uma função não é especificado em sua definição, o sistema de inferência de tipos deduz o tipo mais geral possível.
Para a função de soma, o tipo inferido seria $Num\ a \Rightarrow a \rightarrow a \rightarrow a$.
Esse tipo indica que a função pode ser aplicada a qualquer tipo \texttt{a}, desde que a pertença à classe \texttt{Num}, ou seja, a função é polimórfica, mas com a restrição de que os tipos envolvidos devem ser numéricos.

Dessa forma, a função pode ser usada tanto para somar inteiros quanto para somar valores de outros tipos numéricos, como \texttt{Float} ou \texttt{Double}.
O polimorfismo restrito (ou polimorfismo ad-hoc) é o que permite essa generalização \cite{PIERCE2002}, pois a função é capaz de operar sobre múltiplos tipos, mas dentro de uma classe específica de tipos, garantindo flexibilidade e segurança no sistema de tipos.

% Falar sobre Cálculo Lambda Simplesmente Tipado
O Cálculo Lambda Simplesmente Tipado (STLC, do inglês \textit{Simply Typed Lambda Calculus}) é uma extensão do cálculo lambda que incoropora tipos.
Enquanto o cálculo lambda não tipado permite qualquer aplicação de funções sem retrições, o STLC assegura que as funções sejam aplicadas apenas a argumentos do tipo correto.
Isso é feito ao associar um tipo a cada variável e garantir que as operações respeitem essas associações.

No STLC, o único construtor de tipos disponível é o tipo de função, denotado por $\tau_1 \to \tau_2$, que representa funções que recebem um argumento de tipo $\tau_1$ e retornam um resultado de tipo $\tau_2$.
Essa simplicidade é uma característica fundamental do sistema que torna o exemplo mais básico de um sistema de tipos.

Tipos simples podem ser definidos de forma recursiva a partir de um conjunto de tipos base. Um exemplo clássico desse sistema seria $Int$ para inteiros e $Bool$ para booleanos.
A partir desses tipo base, podemos formar tipos compostos.
Por exemplo, o tipo de uma função que recebe um inteiro e retorna outro inteiro seria $Int \to Int$.
Para funções mais complexas, o STLC permite a construção de tuipos com várias entradas e saídas.
Por exemplo uma função que recebe um inteiro e um booleano e retorna um inteiro seria tipada como $Int \to Bool \to Int$.

% Apresentar a sintaxe dele
A sintaxe do STLC pode ser definida com a seguinte gramática:

\begin{equation} \label{eq:stlc}
  e::=x\mid \lambda x{\mathbin {:}}\tau .e\mid e\,e\mid c
\end{equation}

% Explicar a sintaxe
Tal qual o formalismo, a sintaxe é uma extensão da sintaxe do cálculo lambda, recebendo a adição de anotações de tipos nas abstrações.

% Relacionar lógica intuicionista e cálculo lambda simplesmente tipado
%% O cálculo lambda simplesmente tipado também está intimamente relacionado à lógica intuicionista, onde proposições podem ser vistas como tipos, e provas como programas. Essa correspondência é um princípio-chave da Teoria de Tipos.

% Correspondência Curry-Howard
%% A Correspondência Curry-Howard formaliza a relação entre lógica e computação, associando tipos a proposições e programas a demonstrações. Esse princípio é fundamental para entender a base teórica por trás da inferência de tipos, especialmente quando se trata da inferência de tipos polimórficos.

% Explicar como a inferência de tipos funciona e sua importância:
%% A inferência de tipos é o processo automático de determinar o tipo de uma expressão sem a necessidade de anotações explícitas. Algoritmos como o Algoritmo W são responsáveis por inferir tipos de maneira eficiente, permitindo que linguagens de programação modernas mantenham a sintaxe simples e concisa, enquanto oferecem garantias de segurança tipológica.
%% A inferência de tipos é um processo que automatiza a dedução de tipos em expressões, sem a necessidade de anotações explícitas. Algoritmos como o Algoritmo W, discutido no próximo capítulo, são essenciais para que linguagens funcionais modernas possam realizar essa inferência de maneira eficiente.

% Conectar com o próximo capítulo (Sistema Damas-Milner e Algoritmo W):
%% O Sistema Damas-Milner, discutido no próximo capítulo, representa uma grande inovação na inferência de tipos, introduzindo a ideia de polimorfismo de Hindley-Milner, no qual o Algoritmo W é central. Este sistema forma a base de muitos sistemas de tipos polimórficos em linguagens funcionais modernas, e a sua extensão para o estilo CPS será discutida mais adiante.
%% O Sistema Damas-Milner, que será discutido no próximo capítulo, expande a inferência de tipos para sistemas polimórficos. O Algoritmo W, que é o coração desse sistema, desempenha um papel crucial na dedução automática de tipos em linguagens com tipagem polimórfica, preparando o terreno para sua extensão no contexto CPS.
