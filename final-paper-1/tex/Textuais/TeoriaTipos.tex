\chapter{Teoria de Tipos} \label{ch:type-theory}

% Introdução Teoria de Tipos (Paradoxo de Russel)
A Teoria de Tipos, conforme apresentada por \cite{COQUAND2022}, foi introduzida por Russell em 1908 ao encontrar um paradoxo na Teoria de Conjuntos, conhecido atualmente como o Paradoxo de Russell:

% Definição do paradoxo
\begin{equation} \label{eq:russell-paradox}
  \text{Seja } R = \{ x \mid x \notin x \}, \text{ então } R \in R \iff R \notin R
\end{equation}

% Explicação da definição
Ou seja, considere $R$ como o conjunto dos conjuntos que não contêm a si mesmos.
A contradição surge ao observar que, se o conjunto $R$ contém a si mesmo, isso implica que $R$ não contém a si mesmo, e vice-versa.

% Paradoxo do barbeiro
Outra maneira de descrever esse paradoxo é através do Paradoxo do Barbeiro: imagine uma cidade com apenas um barbeiro, onde ele somente barbeia aqueles que não se barbeiam.
O paradoxo surge quando perguntamos: ``Quem barbeia o barbeiro?''.
Ele não pode fazer sua própria barba, pois barbeia apenas aqueles que não fazem a própria barba.
No entanto, se ele não faz sua própria barba, então pertence ao grupo daqueles que devem ser barbeados pelo barbeiro, logo, ele deveria barbear-se.
Essa situação gera uma contradição semelhante ao Paradoxo de Russell.

% Utilidade Teoria de Tipos
Atualmente, a principal aplicação da Teoria de Tipos está na formalização de sistemas de tipos para linguagens de programação.
Ela tem diversas utilidades, como em assistentes de prova que utilizam sistemas de tipos para codificar provas.
Por exemplo, o Coq \cite{COQUAND1998} utiliza o Cálculo de Construções.
Além disso, a Teoria de Tipos é fundamental em algoritmos de checagem de tipos, que fazem parte da análise semântica em compiladores, bem como na inferência de tipos em linguagens de programação, como o Cálculo Lambda Simplesmente Tipado.

% Introduzir conceitos de tipos simples, tipos dependentes e tipos polimórficos:
No contexto das linguagens de programação, podemos distinguir três categorias principais de tipos: tipos simples, tipos polimórficos e tipos dependentes \cite{PIERCE2002}.
Tipos simples atribuem um tipo fixo a cada termo, enquanto tipos polimórficos introduzem a noção de generalidade, permitindo que funções possam ser aplicadas a argumentos de diferentes tipos sem a necessidade de serem redefinidas para cada um.
Já os tipos dependentes permitem que tipos dependam de valores.

% Exemplo 1: Tipos Simples
Um exemplo de tipo simples é uma função que opera sobre números inteiros.
Esta função recebe um número inteiro e retorna outro número inteiro.
Seu tipo, portanto, é representado como $Int \rightarrow Int$, indicando que tanto a entrada quanto a saída são do tipo inteiro.

% Exemplo 2: Tipos Polimórficos
Um exemplo de polimorfismo é a função identidade, que recebe um elemento de qualquer tipo e retorna o mesmo elemento.
Seu tipo é expresso como $a \rightarrow a$, onde $a$ pode ser qualquer tipo.
Este tipo polimórfico indica que a função identidade pode ser usada com diferentes tipos de dados sem precisar ser modificada.

% Exemplo 3: Tipos Dependentes
Em linguagens com suporte a tipos dependentes, um exemplo seria o de um vetor cujo comprimento (número de elementos) faz parte de seu tipo.
Nesse caso, uma função de concatenação de vetores deve garantir que somente vetores com tipos compatíveis em relação ao comprimento possam ser concatenados.
O tipo da função de concatenação seria algo como\footnote{A notação exata pode variar entre diferentes linguagens de programação que suportam tipos dependentes. A estrutura apresentada serve apenas como uma ilustração conceitual do comportamento esperado.} $Vector(n) \rightarrow Vector(m) \rightarrow Vector(n+m)$, onde $n$ e $m$ são valores que representam os comprimentos dos vetores e fazem parte da definição de tipo.

% Especificar como polimorfismo se relaciona com a inferência de tipos:
O polimorfismo desempenha um papel crucial na inferência de tipos.
Em linguagens com suporte a inferência de tipos, como Haskell, o sistema de tipos é capaz de deduzir tanto tipos específicos quanto tipos genéricos, sempre que possível, para permitir polimorfismo \cite{PIERCE2002}.
O polimorfismo refere-se à capacidade de uma função ou expressão operar sobre diferentes tipos de dados de forma genérica.
Um exemplo clássico é a função identidade, $\lambda x.x$, que pode ser tipada como $\forall \alpha. \alpha \to \alpha$, indicando que a função aceita um valor de qualquer tipo $\alpha$ e retorna um valor do mesmo tipo.
Esse tipo é conhecido como polimorfismo universal \cite{PIERCE2002}.

Já a função de soma apresentada na Figura \ref{code:add} demonstra outro tipo de polimorfismo.
Como possui tipagem explícita $Int \rightarrow Int \rightarrow Int$, apenas valores do tipo inteiro podem ser somados.
No entanto, essa mesma função pode ser generalizada para permitir a soma de quaisquer números, contanto que sejam do mesmo tipo.
Aqui entra o conceito de restrição de classe de tipos.

Em Haskell, uma classe de tipos é um conjunto de tipos que compartilham um conjunto comum de operações.
A classe \texttt{Num}, por exemplo, é a classe de tipos que suportam operações numéricas, como adição e multiplicação.
Quando o tipo de uma função não é especificado em sua definição, o sistema de inferência de tipos deduz o tipo mais geral possível.
Para a função de soma, o tipo inferido seria $Num\ a \Rightarrow a \rightarrow a \rightarrow a$.
Esse tipo indica que a função pode ser aplicada a qualquer tipo \texttt{a}, desde que a pertença à classe \texttt{Num}, ou seja, a função é polimórfica, mas com a restrição de que os tipos envolvidos devem ser numéricos.

Dessa forma, a função pode ser usada tanto para somar inteiros quanto para somar valores de outros tipos numéricos, como \texttt{Float} ou \texttt{Double}.
O polimorfismo restrito (ou polimorfismo ad-hoc) é o que permite essa generalização \cite{PIERCE2002}, pois a função é capaz de operar sobre múltiplos tipos, mas dentro de uma classe específica de tipos, garantindo flexibilidade e segurança no sistema de tipos.

% Seções sobre diferentes abordagens para checagem de tipos (estática vs dinâmica):
%% Uma distinção fundamental entre os sistemas de tipos está na maneira como os tipos são verificados: a checagem estática e a checagem dinâmica. A checagem estática ocorre durante a compilação, assegurando que os erros de tipo sejam detectados antes da execução do programa. Por outro lado, a checagem dinâmica ocorre durante a execução, proporcionando maior flexibilidade, mas com a desvantagem de que erros de tipo podem surgir tardiamente.
%% A checagem de tipos pode ser feita de forma estática (durante a compilação) ou dinâmica (durante a execução). A checagem estática, como ocorre em linguagens como Haskell, oferece maior segurança ao detectar erros de tipos antes da execução do programa.

% Falar sobre Cálculo Lambda Simplesmente Tipado
%% O Cálculo Lambda Simplesmente Tipado é uma extensão do cálculo lambda com a adição de tipos. Sua sintaxe é composta por variáveis tipadas, abstrações e aplicações. A tipagem garante que funções e aplicações respeitem regras semânticas, prevenindo operações inválidas.

% Apresentar a sintaxe dele
%% A sintaxe formal do cálculo lambda simplesmente tipado pode ser representada da seguinte maneira:
%% \[
%%   t ::= x \mid \lambda x:T.t \mid t_1 t_2
%% \]
%% \[
%%   T ::= A \mid T \to T
%% \]
%% Essa sintaxe descreve como os termos são construídos e como os tipos são atribuídos a eles, evitando contradições e erros.

% Explicar a sintaxe
%% Cada termo é tipado com uma função $T \to T$, onde $T$ é o tipo do argumento e o tipo do resultado. Isso assegura que operações semânticas incorretas, como adicionar uma função a um inteiro, sejam evitadas.

% Relacionar lógica intuicionista e cálculo lambda simplesmente tipado
%% O cálculo lambda simplesmente tipado também está intimamente relacionado à lógica intuicionista, onde proposições podem ser vistas como tipos, e provas como programas. Essa correspondência é um princípio-chave da Teoria de Tipos.

% Correspondência Curry-Howard
%% A Correspondência Curry-Howard formaliza a relação entre lógica e computação, associando tipos a proposições e programas a demonstrações. Esse princípio é fundamental para entender a base teórica por trás da inferência de tipos, especialmente quando se trata da inferência de tipos polimórficos.

% Explicar como a inferência de tipos funciona e sua importância:
%% A inferência de tipos é o processo automático de determinar o tipo de uma expressão sem a necessidade de anotações explícitas. Algoritmos como o Algoritmo W são responsáveis por inferir tipos de maneira eficiente, permitindo que linguagens de programação modernas mantenham a sintaxe simples e concisa, enquanto oferecem garantias de segurança tipológica.
%% A inferência de tipos é um processo que automatiza a dedução de tipos em expressões, sem a necessidade de anotações explícitas. Algoritmos como o Algoritmo W, discutido no próximo capítulo, são essenciais para que linguagens funcionais modernas possam realizar essa inferência de maneira eficiente.

% Conectar com o próximo capítulo (Sistema Damas-Milner e Algoritmo W):
%% O Sistema Damas-Milner, discutido no próximo capítulo, representa uma grande inovação na inferência de tipos, introduzindo a ideia de polimorfismo de Hindley-Milner, no qual o Algoritmo W é central. Este sistema forma a base de muitos sistemas de tipos polimórficos em linguagens funcionais modernas, e a sua extensão para o estilo CPS será discutida mais adiante.
%% O Sistema Damas-Milner, que será discutido no próximo capítulo, expande a inferência de tipos para sistemas polimórficos. O Algoritmo W, que é o coração desse sistema, desempenha um papel crucial na dedução automática de tipos em linguagens com tipagem polimórfica, preparando o terreno para sua extensão no contexto CPS.
