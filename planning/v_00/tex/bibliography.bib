@article{PLOTKIN1975125,
  title    = {Call-by-name, call-by-value and the $\lambda$-calculus},
  journal  = {Theoretical Computer Science},
  volume   = {1},
  number   = {2},
  pages    = {125-159},
  year     = {1975},
  issn     = {0304-3975},
  doi      = {https://doi.org/10.1016/0304-3975(75)90017-1},
  url      = {https://www.sciencedirect.com/science/article/pii/0304397575900171},
  author   = {G.D. Plotkin},
  abstract = {This paper examines the old question of the relationship between ISWIM and the λ-calculus, using the distinction between call-by-value and call-by-name. It is held that the relationship should be mediated by a standardisation theorem. Since this leads to difficulties, a new λ-calculus is introduced whose standardisation theorem gives a good correspondence with ISWIM as given by the SECD machine, but without the letrec feature. Next a call-by-name variant of ISWIM is introduced which is in an analogous correspondence withthe usual λ-calculus. The relation between call-by-value and call-by-name is then studied by giving simulations of each language by the other and interpretations of each calculus in the other. These are obtained as another application of the continuation technique. Some emphasis is placed throughout on the notion of operational equality (or contextual equality). If terms can be proved equal in a calculus they are operationally equal in the corresponding language. Unfortunately, operational equality is not preserved by either of the simulations.}
}

@inproceedings{KENNEDY2007,
  author    = {Kennedy, Andrew},
  title     = {Compiling with continuations, continued},
  year      = {2007},
  isbn      = {9781595938152},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1291151.1291179},
  doi       = {10.1145/1291151.1291179},
  abstract  = {We present a series of CPS-based intermediate languages suitable for functional language compilation, arguing that they have practical benefits over direct-style languages based on A-normal form (ANF) or monads. Inlining of functions demonstrates the benefits most clearly: in ANF-based languages, inlining involves a re-normalization step that rearranges let expressions and possibly introduces a new 'join point' function, and in monadic languages, commuting conversions must be applied; in contrast, inlining in our CPS language is a simple substitution of variables for variables.We present a contification transformation implemented by simple rewrites on the intermediate language. Exceptions are modelled using so-called 'double-barrelled' CPS. Subtyping on exception constructors then gives a very straightforward effect analysis for exceptions. We also show how a graph-based representation of CPS terms can be implemented extremely efficiently, with linear-time term simplification.},
  booktitle = {Proceedings of the 12th ACM SIGPLAN International Conference on Functional Programming},
  pages     = {177–190},
  numpages  = {14},
  keywords  = {continuation passing style, continuations, functional programming languages, monads, optimizing compilation},
  location  = {Freiburg, Germany},
  series    = {ICFP '07}
}

@inproceedings{FLANAGAN1993,
  author    = {Flanagan, Cormac and Sabry, Amr and Duba, Bruce F. and Felleisen, Matthias},
  title     = {The essence of compiling with continuations},
  year      = {1993},
  isbn      = {0897915984},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/155090.155113},
  doi       = {10.1145/155090.155113},
  abstract  = {In order to simplify the compilation process, many compilers for higher-order languages use the continuation-passing style (CPS) transformation in a first phase to generate an intermediate representation of the source program. The salient aspect of this intermediate form is that all procedures take an argument that represents the rest of the computation (the “continuation”). Since the nai¨ve CPS transformation considerably increases the size of programs, CPS compilers perform reductions to produce a more compact intermediate representation. Although often implemented as a part of the CPS transformation, this step is conceptually a second phase. Finally, code generators for typical CPS compilers treat continuations specially in order to optimize the interpretation of continuation parameters.A thorough analysis of the abstract machine for CPS terms show that the actions of the code generator invert the nai¨ve CPS translation step. Put differently, the combined effect of the three phases is equivalent to a source-to-source transformation that simulates the compaction phase. Thus, fully developed CPS compilers do not need to employ the CPS transformation but can achieve the same results with a simple source-level transformation.},
  booktitle = {Proceedings of the ACM SIGPLAN 1993 Conference on Programming Language Design and Implementation},
  pages     = {237–247},
  numpages  = {11},
  location  = {Albuquerque, New Mexico, USA},
  series    = {PLDI '93}
}

@article{MORRISSET1999,
  author     = {Morrisett, Greg and Walker, David and Crary, Karl and Glew, Neal},
  title      = {From system F to typed assembly language},
  year       = {1999},
  issue_date = {May 1999},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {21},
  number     = {3},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/319301.319345},
  doi        = {10.1145/319301.319345},
  abstract   = {We motivate the design of typed assembly language (TAL) and present a type-preserving ttranslation from Systemn F to TAL. The typed assembly language we pressent is based on a conventional RISC assembly language, but its static type sytem provides support for enforcing high-level language abstratctions, such as closures, tuples, and user-defined abstract data types. The type system ensures that well-typed programs cannot violatet these abstractionsl In addition, the typing constructs admit many low-level compiler optimiztaions. Our translation to TAL is specified as a sequence of type-preserving transformations, including CPS and closure conversion phases; type-correct source programs are mapped to type-correct assembly language. A key contribution is an approach to polymorphic   closure conversion that is considerably simpler than previous work. The compiler and typed assembly lanugage provide a fully automatic way to produce certified code, suitable for use in systems where unstrusted and potentially malicious code must be checked for safety before execution.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = {may},
  pages      = {527-568},
  numpages   = {42},
  keywords   = {certified code, closure conversion, secure extensible systems, type-directed compilation, typed assembly language, typed intermediate languages}
}

@article{TORRENS2024,
  author     = {Torrens, Paulo and Orchard, Dominic and Vasconcellos, Cristiano},
  title      = {On the Operational Theory of the CPS-Calculus: Towards a Theoretical Foundation for IRs},
  year       = {2024},
  issue_date = {August 2024},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {8},
  number     = {ICFP},
  url        = {https://doi.org/10.1145/3674630},
  doi        = {10.1145/3674630},
  abstract   = {The continuation-passing style translation often employed by compilers gives rise to a class of intermediate representation languages where functions are not allowed to return anymore. Though the primary use of these intermediate representation languages is to expose details about a program's control flow, they may be equipped with an equational theory in order to be seen as specialized calculi, which in turn may be related to the original languages by means of a factorization theorem. In this paper, we explore Thielecke's CPS-calculus, a small theory of continuations inspired by compiler implementations, and study its metatheory. We extend it with a sound reduction semantics that faithfully represents optimization rules used in actual compilers, and prove that it acts as a suitable theoretical foundation for the intermediate representation of Appel's and Kennedy's compilers by following the guidelines set out by Plotkin. Finally, we prove that the CPS-calculus is strongly normalizing in the simply typed setting by using a novel proof method for reasoning about reducibility at a distance, from which logical consistency follows. Taken together, these results close a gap in the existing literature, providing a formal theory for reasoning about intermediate representations.},
  journal    = {Proc. ACM Program. Lang.},
  month      = {aug},
  articleno  = {241},
  numpages   = {30},
  keywords   = {Continuations, intermediate representations, strong normalization}
}
