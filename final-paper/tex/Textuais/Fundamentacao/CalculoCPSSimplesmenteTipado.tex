\section{Cálculo CPS Simplesmente Tipado}\label{sec:cps-calculus-thielecke}
\citeonline{thielecke1997categorical} em sua tese, a partir de uma perspectiva profundamente categórica, tanto em suas definições quanto nas formalizações.
Esse tratamento, no entanto, ultrapassa o escopo deste trabalho.
Ainda que a compreensão de sua abordagem seja útil para o entendimento do sistema de tipos aqui apresentado, não será abordado aqui os aspectos de Teoria das Categorias em detalhe.

Neste sistema, há apenas um construtor de tipos: a negação poliádica (do inglês \textit{polyadic negation type}), usada para representar continuações~\cite{torrens2024operational}.
Além disso, $X$ varia sobre os tipos base.

\phantom{Newline}

\begin{tabular}{lccl}
  Tipos & $\tau$ & $\Coloneqq$ & $\neg\vv{\tau} \enspace|\enspace X$ \\
  Contexto & $\Gamma$ & $\Coloneqq$ & $\cdot \enspace|\enspace \Gamma,\ x{:}\ \tau$ \\
\end{tabular}\label{cps-simple-type-system}

\phantom{Newline}

\noindent O sistema apresenta duas regras de tipagem principais, uma para o \textit{jump} $\mathtt{[J]}$ e outra para o \textit{bind} $\mathtt{[B]}$.

\phantom{Newline}

\fbox{$\Gamma\vdash b$}

\begin{prooftree}
    \RightLabel{$\mathtt{[J]}$}
    \AxiomC{$\Gamma(k) = \neg\vv{\tau}$}
    \AxiomC{$\Gamma(\vv{x}) = \vv{\tau}$}
    \BinaryInfC{$\Gamma\vdash k(\vv{x})$}
\end{prooftree}
\begin{prooftree}
    \RightLabel{$\mathtt{[B]}$}
    \AxiomC{$\Gamma,\ k{:}\ \neg\vv{\tau} \vdash b$}
    \AxiomC{$\Gamma,\ \vv{x}{:}\ \vv{\tau} \vdash c$}
    \BinaryInfC{$\mathtt{let}\ k(\vv{x}) = c\ \mathtt{in}\ b$}
\end{prooftree}
Os julgamentos de tipo nesse cálculo são unilaterais.
Diferentemente do cálculo de tipos tradicional como o de Damas-Milner, onde um julgamento do tipo $\Gamma \vdash e{:}\ \tau$ atribui um tipo $\tau$ à expressão $e$ sob o contexto $\Gamma$, no cálculo CPS é escrito apenas $\Gamma \vdash b$.
Isso significa que, sob o contexto $\Gamma$, o termo $b$ é consistente, ou seja, não vai falhar durante a execução~\cite{thielecke1997categorical}.
Por exemplo, a derivação ${x{:}\ \tau,\ k{:}\ \neg\tau} \vdash k(x)$ indica que, assumindo $x$ com tipo $\tau$ e $k$ com tipo $\neg\tau$, passar $x$ como argumento para $k$ é seguro.

\citeonline{torrens2024operational} demonstram a segurança de tipos (do inglês \textit{type safety}) deste sistema, provando as propriedades de preservação e progresso.
Isso garante que expressões bem tipadas não entram em estados inválidos ao serem avaliadas.

Um contraste interessante pode ser observado entre o sistema Damas-Milner e o cálculo CPS.
No primeiro, as expressões são testemunhas da veracidade de seus tipos.
Já no segundo, as expressões podem ser vistas como testemunhas de que o contexto de tipos leva a uma contradição {---} nas palavras de Thielecke, ``$M$ witnesses that $\Gamma$ entails a contradiction".

\subsection{Tradução CPS}\label{subsec:cps-translation}
O processo de tradução, no contexto de linguagens é a etapa em que um código feito em uma linguagem é transcrito para outra, onde idealmente, semântica alguma deve ser perdida.
\citeonline{plotkin1975call} introduz duas traduções do cálculo-$\lambda$ para o cálculo de CPS, que se diferenciam de acordo com a estratégia de avaliação.
A tradução por chamada por nome (CBN do inglês \textit{call-by-name}) para o cálculo-$\lambda$ permite que sua execução seja simulada no cálculo-${\lambda}_N$, representada por ${\llbracket - \rrbracket}_N$, e de maneira semelhante, a tradução chamada por valor (CBV do inglês \textit{call-by-value}) para o cálculo-${\lambda}_V$, representada por ${\llbracket - \rrbracket}_V$.
Apesar de que estas traduções não sejam as mais eficientes, por sua simplicidade, estas foram escolhidas por sua simplicidade.

\phantom{Newline}

\fbox{${\llbracket\ e\ \rrbracket}_N\ =\ b$} \textit{Plotkin's call-by-name translation}

\begin{tabular}{lcl}
  ${\llbracket\ x\ \rrbracket}_N$ & $=$ & $x(k)$ \\
  ${\llbracket\ \lambda x.\ e\ \rrbracket}_N$ & $=$ & $\mathtt{let}\ v(k,\ x) = {\llbracket e \rrbracket}_N\ \mathtt{in}\ k(v)$ \\
  ${\llbracket\ f\ e\ \rrbracket}_N$ & $=$ & $\mathtt{let}\ k(f) = \mathtt{let}\ v(k) = {\llbracket\ e\ \rrbracket}_N\ \mathtt{in}\ c\ \mathtt{in}\ {\llbracket\ f\ \rrbracket}_N$ \\
  ${\llbracket\ \mathtt{let}\ x = f\ \mathtt{in}\ e \rrbracket}_N$ & $=$ & $\mathtt{let}\ x(k) = {\llbracket\ b\ \rrbracket}_N\ \mathtt{in}\ {\llbracket\ a\ \rrbracket}_N$
\end{tabular}

\phantom{Newline}

\fbox{${\llbracket\ e\ \rrbracket}_V\ =\ b$} \textit{Plotkin's call-by-value translation}

\begin{tabular}{lcl}
  ${\llbracket\ x\ \rrbracket}_V$ & $=$ & $k(x)$ \\
  ${\llbracket\ \lambda x.\ e\ \rrbracket}_V$ & $=$ & $\mathtt{let}\ v(k,\ x) = {\llbracket e \rrbracket}_V\ \mathtt{in}\ k(v)$ \\
  ${\llbracket\ f\ e\ \rrbracket}_V$ & $=$ & $\mathtt{let}\ k(f) = \mathtt{let}\ v(k) = c\ \mathtt{in}\ {\llbracket\ e\ \rrbracket}_V\ \mathtt{in}\ {\llbracket\ f\ \rrbracket}_V$ \\
  ${\llbracket\ \mathtt{let}\ x = f\ \mathtt{in}\ e \rrbracket}_V$ & $=$ & $\mathtt{let}\ k(x) = {\llbracket\ a\ \rrbracket}_V\ \mathtt{in}\ {\llbracket\ b\ \rrbracket}_V$
\end{tabular}

\phantom{Newline}

\noindent As variáveis $f$, $v$ e $k$ que não aparecem no termo de origem são consideradas frescas, onde as duas primeiras são imediatamente ligadas, enquanto que $k$ é esperada que seja livre e por ser vinculada às traduções dos subtermos, um único $k$ é necessário~\cite{torrens2024operational}.

Ainda, a tradução do `let' não está presente no artigo.
Esta foi feita para que o trabalho em questão pudesse ser mais completo e mais próximo de algo utilizável em um caso real de implementação de compilador com uso desta IR.
A maneira de se obtê-la foi a partir de uma beta-redex, simplificando a tradução de $((\lambda x.\ b)\ a)$.

Além da tradução de expressões, uma vez que o ambiente sendo trabalhado é tipado, é necessário que a tradução preserve a tipagem dos programas,~\citeonline{torrens2024operational} apresentam a tradução tipada do CPS, onde, para o tipo funcional $\mathtt{A \Coloneqq A \to A\ |\ X}$, as seguintes traduções são definidas.
Note que aqui também as funções são definidas diferentemente de acordo com estratégia de avaliação adotada:

\phantom{Newline}

\begin{tabular}{lcl}
     ${\llbracket\ X\ \rrbracket}_N$ & $=$ & $\neg X$ \\ 
     ${\llbracket\ A \rightarrow B\ \rrbracket}_N$ & $=$ & $\neg\neg(\neg{\llbracket\ A\ \rrbracket}_N,\ {\llbracket\ B\ \rrbracket}_N)$ \\ 
     ${\llbracket\ \vv{x}{:}\ \vv{A} \vdash e{:}\ B\ \rrbracket}_N$ & $=$ & $\vv{x}{:}\ \vv{\neg{\llbracket\ A\ \rrbracket}_N},\ k{:}\ {\llbracket\ B\ \rrbracket}_N \vdash {\llbracket\ e\ \rrbracket}_N$ \\ 
\end{tabular}

\phantom{Newline}

\begin{tabular}{lcl}
     ${\llbracket\ X\ \rrbracket}_V$ & $=$ & $X$ \\ 
     ${\llbracket\ A \rightarrow B\ \rrbracket}_V$ & $=$ & $\neg({\llbracket\ A\ \rrbracket}_V,\ \neg{\llbracket\ B\ \rrbracket}_V)$ \\ 
     ${\llbracket\ \vv{x}{:}\ \vv{A} \vdash e{:}\ B\ \rrbracket}_V$ & $=$ & $\vv{x}{:}\ \vv{{\llbracket\ A\ \rrbracket}_V},\ k{:}\ \neg{\llbracket\ B\ \rrbracket}_V \vdash {\llbracket\ e\ \rrbracket}_V$ \\ 
\end{tabular}

\phantom{Newline}

\noindent Esta função de tradução tem como propósito, mostrar que se o termo lambda é tipado, então o termo traduzido para CPS também é tipado.
É importante notar que isto se aplica somente para os tipos simples, como definido no tipo funcional a partir do tipo primitivo $\mathtt{X}$ e do \textit{arrow type} $\mathtt{A \to A}$.
O sistema de tipos proposto neste trabalho, entretanto, é polimórfico, ou seja, aqui há a adição de variáveis de tipos quantificadas.
Sendo assim, esta função de tradução, se aplicando neste caso de uso, não necessariamente retornará o tipo mais geral de uma expressão, mas sempre um subtipo deste.

\subsection{Tradução Tipada do CPS}\label{subsec:typed-cps-translation}
Além da tradução de expressões, uma vez que o ambiente sendo trabalhado é tipado, é necessário que a tradução preserve a tipagem dos programas,~\citeonline{torrens2024operational} apresentam a tradução tipada do CPS, onde, para o tipo funcional $\mathtt{A \Coloneqq A \to A\ |\ X}$, as seguintes traduções são definidas.
Note que aqui também as funções são definidas diferentemente de acordo com estratégia de avaliação adotada:

\phantom{Newline}

\begin{tabular}{lcl}
     ${\llbracket\ X\ \rrbracket}_N$ & $=$ & $\neg X$ \\ 
     ${\llbracket\ A \rightarrow B\ \rrbracket}_N$ & $=$ & $\neg\neg(\neg{\llbracket\ A\ \rrbracket}_N,\ {\llbracket\ B\ \rrbracket}_N)$ \\ 
     ${\llbracket\ \vv{x}{:}\ \vv{A} \vdash e{:}\ B\ \rrbracket}_N$ & $=$ & $\vv{x}{:}\ \vv{\neg{\llbracket\ A\ \rrbracket}_N},\ k{:}\ {\llbracket\ B\ \rrbracket}_N \vdash {\llbracket\ e\ \rrbracket}_N$ \\ 
\end{tabular}

\phantom{Newline}

\begin{tabular}{lcl}
     ${\llbracket\ X\ \rrbracket}_V$ & $=$ & $X$ \\ 
     ${\llbracket\ A \rightarrow B\ \rrbracket}_V$ & $=$ & $\neg({\llbracket\ A\ \rrbracket}_V,\ \neg{\llbracket\ B\ \rrbracket}_V)$ \\ 
     ${\llbracket\ \vv{x}{:}\ \vv{A} \vdash e{:}\ B\ \rrbracket}_V$ & $=$ & $\vv{x}{:}\ \vv{{\llbracket\ A\ \rrbracket}_V},\ k{:}\ \neg{\llbracket\ B\ \rrbracket}_V \vdash {\llbracket\ e\ \rrbracket}_V$ \\ 
\end{tabular}

\phantom{Newline}

\noindent Esta função de tradução tem como propósito, mostrar que se o termo lambda é tipado, então o termo traduzido para CPS também é tipado.
É importante notar que isto se aplica somente para os tipos simples, como definido no tipo funcional a partir do tipo primitivo $\mathtt{X}$ e do \textit{arrow type} $\mathtt{A \to A}$.
