@article{appel1998ssa,
  title     = {SSA is functional programming},
  author    = {Appel, Andrew W},
  journal   = {Acm Sigplan Notices},
  volume    = {33},
  number    = {4},
  pages     = {17--20},
  year      = {1998},
  publisher = {ACM New York, NY, USA}
}

@inproceedings{cytron1989efficient,
  title     = {An efficient method of computing static single assignment form},
  author    = {Cytron, Ron and Ferrante, Jeanne and Rosen, Barry K and Wegman, Mark N and Zadeck, F Kenneth},
  booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  pages     = {25--35},
  year      = {1989},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  location  = {Austin, Texas, USA}
}

@article{wegman1991constant,
  title     = {Constant propagation with conditional branches},
  author    = {Wegman, Mark N and Zadeck, F Kenneth},
  journal   = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume    = {13},
  number    = {2},
  pages     = {181--210},
  year      = {1991},
  publisher = {ACM New York, NY, USA}
}

@article{hughes1989functional,
  title     = {Why functional programming matters},
  author    = {Hughes, John},
  journal   = {The computer journal},
  volume    = {32},
  number    = {2},
  pages     = {98--107},
  year      = {1989},
  publisher = {Oxford University Press}
}

@inproceedings{vazou2016monads,
  title        = {From monads to effects and back},
  author       = {Vazou, Niki and Leijen, Daan},
  booktitle    = {Practical Aspects of Declarative Languages: 18th International Symposium},
  pages        = {169--186},
  year         = {2016},
  organization = {Springer},
  address      = {St. Petersburg, FL, USA}
}

@inproceedings{torrens2017hybrid,
  title     = {A hybrid intermediate language between SSA and CPS},
  author    = {Torrens, Paulo and Vasconcellos, Cristiano and Gon{\c{c}}alves, Junia},
  booktitle = {Proceedings of the 21st Brazilian Symposium on Programming Languages},
  pages     = {1--3},
  year      = {2017},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA}
}

@article{church1932set,
  title     = {A set of postulates for the foundation of logic},
  author    = {Church, Alonzo},
  journal   = {Annals of mathematics},
  pages     = {346--366},
  year      = {1932},
  publisher = {JSTOR}
}

@inproceedings{wadler1995monads,
  title        = {Monads for functional programming},
  author       = {Wadler, Philip},
  booktitle    = {Advanced Functional Programming: First International Spring School on Advanced Functional Programming Techniques},
  pages        = {24--52},
  year         = {1995},
  organization = {Springer},
  address      = {B{\aa}stad, Sweden}
}

@article{leijen2014koka,
  title   = {Koka: Programming with row polymorphic effect types},
  author  = {Leijen, Daan},
  journal = {arXiv preprint arXiv:1406.2061},
  year    = {2014}
}

@inproceedings{rigon2020inferring,
  title     = {Inferring types and effects via static single assignment},
  author    = {Rigon, Leonardo Filipe and Torrens, Paulo and Vasconcellos, Cristiano},
  booktitle = {Proceedings of the 35th Annual ACM Symposium on Applied Computing},
  pages     = {1314--1321},
  year      = {2020},
  address   = {New York, NY, USA},
  publisher = {Association for Computing Machinery}
}

@inproceedings{flanagan1993essence,
  title     = {The essence of compiling with continuations},
  author    = {Flanagan, Cormac and Sabry, Amr and Duba, Bruce F and Felleisen, Matthias},
  booktitle = {Proceedings of the ACM SIGPLAN 1993 conference on Programming language design and implementation},
  pages     = {237--247},
  year      = {1993},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA}
}
@book{aho2008compilers,
  title       = {Compiladores: Princípios, técnicas e ferramentas},
  author      = {Aho, Alfred V and Sethi, Ravi and Ullman, Jeffrey D and Lam, Monica S},
  year        = {2008},
  edition     = {2th},
  translation = {Vieira, Daniel},
  publisher   = {Pearson Education},
  address     = {São Paulo, SP, Brasil}
}

@book{cooper2014,
  author    = {Cooper, Keith D and Torczon, Linda},
  title     = {Contruindo Compiladores},
  publisher = {Elsevier},
  edition   = {2th},
  year      = {2014},
  address   = {Rio de Janeiro, RJ, Brasil}
}
@article{allen1970control,
  title     = {Control flow analysis},
  author    = {Allen, Frances E},
  journal   = {ACM Sigplan Notices},
  volume    = {5},
  number    = {7},
  pages     = {1--19},
  year      = {1970},
  publisher = {ACM New York, NY, USA}
}

@article{flanagan1993,
  author     = {Flanagan, Cormac and Sabry, Amr and Duba, Bruce F. and Felleisen, Matthias},
  title      = {The Essence of Compiling with Continuations},
  year       = {1993},
  issue_date = {June 1993},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {28},
  number     = {6},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/173262.155113},
  doi        = {10.1145/173262.155113},
  journal    = {SIGPLAN Not.},
  month      = {jun},
  pages      = {237–247},
  numpages   = {11}
}

@article{sabyr1992,
  author     = {Sabry, Amr and Felleisen, Matthias},
  title      = {Reasoning about Programs in Continuation-Passing Style.},
  year       = {1992},
  issue_date = {Jan. 1992},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {V},
  number     = {1},
  issn       = {1045-3563},
  url        = {https://doi.org/10.1145/141478.141563},
  doi        = {10.1145/141478.141563},
  journal    = {SIGPLAN Lisp Pointers},
  month      = {jan},
  pages      = {288–298},
  numpages   = {11}
}

@inproceedings{appel1987standard,
  title        = {A standard ML compiler},
  author       = {Appel, Andrew W and MacQueen, David B},
  booktitle    = {Conference on Functional Programming Languages and Computer Architecture},
  pages        = {301--324},
  year         = {1987},
  organization = {Springer}
}

@book{steele1978rabbit,
  title     = {Rabbit: A compiler for Scheme},
  author    = {Steele, Guy L},
  year      = {1978},
  publisher = {Massachusetts Institute of Technology}
}

@book{appel1992compiling,
  author    = {Appel, Andrew W.},
  title     = {Compiling with continuations},
  year      = {1992},
  isbn      = {0521416957},
  publisher = {Cambridge University Press},
  address   = {USA}
}

@misc{thielecke1997,
  title     = { Categorical Structure of Continuation Passing Style },
  author    = { Hayo Thielecke },
  year      = { 1997 },
  publisher = { University of Edinburgh. College of Science and Engineering. School of Informatics. }
}

@article{chakravarty2004functional,
  title     = {A functional perspective on SSA optimisation algorithms},
  author    = {Chakravarty, Manuel MT and Keller, Gabriele and Zadarnowski, Patryk},
  journal   = {Electronic Notes in Theoretical Computer Science},
  volume    = {82},
  number    = {2},
  pages     = {347--361},
  year      = {2004},
  publisher = {Elsevier}
}

@article{kelsey1995correspondence,
  title     = {A correspondence between continuation passing style and static single assignment form},
  author    = {Kelsey, Richard A},
  journal   = {ACM SIGPLAN Notices},
  volume    = {30},
  number    = {3},
  pages     = {13--22},
  year      = {1995},
  publisher = {ACM New York, NY, USA}
}

@article{moggi1988computational,
  title     = {Computational lambda-calculus and monads},
  author    = {Moggi, Eugenio},
  year      = {1988},
  publisher = {Citeseer}
}

@book{mitchell_2002,
  place     = {Cambridge},
  title     = {Concepts in Programming Languages},
  doi       = {10.1017/CBO9780511804175},
  publisher = {Cambridge University Press},
  author    = {Mitchell, John C.},
  year      = {2002}
}

@article{cardelli1996type,
  title     = {Type systems},
  author    = {Cardelli, Luca},
  journal   = {ACM Computing Surveys (CSUR)},
  volume    = {28},
  number    = {1},
  pages     = {263--264},
  year      = {1996},
  publisher = {ACM New York, NY, USA}
}

@article{wadler2003marriage,
  title     = {The marriage of effects and monads},
  author    = {Wadler, Philip and Thiemann, Peter},
  journal   = {ACM Transactions on Computational Logic (TOCL)},
  volume    = {4},
  number    = {1},
  pages     = {1--32},
  year      = {2003},
  publisher = {ACM New York, NY, USA}
}
@article{talpin1992polymorphic,
  title     = {Polymorphic type, region and effect inference},
  author    = {Talpin, Jean-Pierre and Jouvelot, Pierre},
  journal   = {Journal of functional programming},
  volume    = {2},
  number    = {3},
  pages     = {245--271},
  year      = {1992},
  publisher = {Cambridge University Press}
}

@article{PLOTKIN1975125,
  title    = {Call-by-name, call-by-value and the $\lambda$-calculus},
  journal  = {Theoretical Computer Science},
  volume   = {1},
  number   = {2},
  pages    = {125-159},
  year     = {1975},
  issn     = {0304-3975},
  doi      = {https://doi.org/10.1016/0304-3975(75)90017-1},
  url      = {https://www.sciencedirect.com/science/article/pii/0304397575900171},
  author   = {G.D. Plotkin},
  abstract = {This paper examines the old question of the relationship between ISWIM and the λ-calculus, using the distinction between call-by-value and call-by-name. It is held that the relationship should be mediated by a standardisation theorem. Since this leads to difficulties, a new λ-calculus is introduced whose standardisation theorem gives a good correspondence with ISWIM as given by the SECD machine, but without the letrec feature. Next a call-by-name variant of ISWIM is introduced which is in an analogous correspondence withthe usual λ-calculus. The relation between call-by-value and call-by-name is then studied by giving simulations of each language by the other and interpretations of each calculus in the other. These are obtained as another application of the continuation technique. Some emphasis is placed throughout on the notion of operational equality (or contextual equality). If terms can be proved equal in a calculus they are operationally equal in the corresponding language. Unfortunately, operational equality is not preserved by either of the simulations.}
}

@inproceedings{KENNEDY2007,
  author    = {Kennedy, Andrew},
  title     = {Compiling with continuations, continued},
  year      = {2007},
  isbn      = {9781595938152},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1291151.1291179},
  doi       = {10.1145/1291151.1291179},
  abstract  = {We present a series of CPS-based intermediate languages suitable for functional language compilation, arguing that they have practical benefits over direct-style languages based on A-normal form (ANF) or monads. Inlining of functions demonstrates the benefits most clearly: in ANF-based languages, inlining involves a re-normalization step that rearranges let expressions and possibly introduces a new 'join point' function, and in monadic languages, commuting conversions must be applied; in contrast, inlining in our CPS language is a simple substitution of variables for variables.We present a contification transformation implemented by simple rewrites on the intermediate language. Exceptions are modelled using so-called 'double-barrelled' CPS. Subtyping on exception constructors then gives a very straightforward effect analysis for exceptions. We also show how a graph-based representation of CPS terms can be implemented extremely efficiently, with linear-time term simplification.},
  booktitle = {Proceedings of the 12th ACM SIGPLAN International Conference on Functional Programming},
  pages     = {177–190},
  numpages  = {14},
  keywords  = {continuation passing style, continuations, functional programming languages, monads, optimizing compilation},
  location  = {Freiburg, Germany},
  series    = {ICFP '07}
}

@article{MORRISSET1999,
  author     = {Morrisett, Greg and Walker, David and Crary, Karl and Glew, Neal},
  title      = {From system F to typed assembly language},
  year       = {1999},
  issue_date = {May 1999},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {21},
  number     = {3},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/319301.319345},
  doi        = {10.1145/319301.319345},
  abstract   = {We motivate the design of typed assembly language (TAL) and present a type-preserving ttranslation from Systemn F to TAL. The typed assembly language we pressent is based on a conventional RISC assembly language, but its static type sytem provides support for enforcing high-level language abstratctions, such as closures, tuples, and user-defined abstract data types. The type system ensures that well-typed programs cannot violatet these abstractionsl In addition, the typing constructs admit many low-level compiler optimiztaions. Our translation to TAL is specified as a sequence of type-preserving transformations, including CPS and closure conversion phases; type-correct source programs are mapped to type-correct assembly language. A key contribution is an approach to polymorphic   closure conversion that is considerably simpler than previous work. The compiler and typed assembly lanugage provide a fully automatic way to produce certified code, suitable for use in systems where unstrusted and potentially malicious code must be checked for safety before execution.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = {may},
  pages      = {527-568},
  numpages   = {42},
  keywords   = {certified code, closure conversion, secure extensible systems, type-directed compilation, typed assembly language, typed intermediate languages}
}

@article{TORRENS2024,
  author     = {Torrens, Paulo and Orchard, Dominic and Vasconcellos, Cristiano},
  title      = {On the Operational Theory of the CPS-Calculus: Towards a Theoretical Foundation for IRs},
  year       = {2024},
  issue_date = {August 2024},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {8},
  number     = {ICFP},
  url        = {https://doi.org/10.1145/3674630},
  doi        = {10.1145/3674630},
  abstract   = {The continuation-passing style translation often employed by compilers gives rise to a class of intermediate representation languages where functions are not allowed to return anymore. Though the primary use of these intermediate representation languages is to expose details about a program's control flow, they may be equipped with an equational theory in order to be seen as specialized calculi, which in turn may be related to the original languages by means of a factorization theorem. In this paper, we explore Thielecke's CPS-calculus, a small theory of continuations inspired by compiler implementations, and study its metatheory. We extend it with a sound reduction semantics that faithfully represents optimization rules used in actual compilers, and prove that it acts as a suitable theoretical foundation for the intermediate representation of Appel's and Kennedy's compilers by following the guidelines set out by Plotkin. Finally, we prove that the CPS-calculus is strongly normalizing in the simply typed setting by using a novel proof method for reasoning about reducibility at a distance, from which logical consistency follows. Taken together, these results close a gap in the existing literature, providing a formal theory for reasoning about intermediate representations.},
  journal    = {Proc. ACM Program. Lang.},
  month      = {aug},
  articleno  = {241},
  numpages   = {30},
  keywords   = {Continuations, intermediate representations, strong normalization}
}

@article{SONDERGAARD1990,
  title     = {Referential transparency, definiteness and unfoldability},
  author    = {S{\o}ndergaard, Harald and Sestoft, Peter},
  journal   = {Acta Inform.},
  publisher = {Springer Nature},
  volume    = 27,
  number    = 6,
  month     = may,
  year      = 1990,
  language  = {en}
}

@mastersthesis{TORRENS2019,
  author = {Paulo Henrique Torrens},
  school = {UDESC},
  title  = {Um Cálculo de Continuações com Tipos Dependentes},
  year   = {2019}
}

@incollection{COQUAND2022,
  author       = {Coquand, Thierry},
  title        = {{Type Theory}},
  booktitle    = {The {Stanford} Encyclopedia of Philosophy},
  editor       = {Edward N. Zalta and Uri Nodelman},
  howpublished = {\url{https://plato.stanford.edu/archives/fall2022/entries/type-theory/}},
  year         = {2022},
  edition      = {{F}all 2022},
  publisher    = {Metaphysics Research Lab, Stanford University}
}

@article{COQUAND1998,
  title   = {The calculus of constructions},
  journal = {Information and Computation},
  volume  = {76},
  number  = {2},
  pages   = {95-120},
  year    = {1988},
  issn    = {0890-5401},
  doi     = {https://doi.org/10.1016/0890-5401(88)90005-3},
  url     = {https://www.sciencedirect.com/science/article/pii/0890540188900053},
  author  = {Thierry Coquand and Gérard Huet}
}

@book{PIERCE2002,
  author    = {Pierce, Benjamin C.},
  title     = {Types and Programming Languages},
  year      = {2002},
  isbn      = {0262162091},
  publisher = {The MIT Press},
  edition   = {1st},
  abstract  = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems -- and of programming languages from a type-theoretic perspective -- has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.}
}

@article{CHURCH1940,
  title     = {A formulation of the simple theory of types},
  author    = {Church, Alonzo},
  abstract  = {The purpose of the present paper is to give a formulation of the
               simple theory of types which incorporates certain features of
               the calculus of $\lambda$-conversion. A complete incorporation
               of the calculus of $\lambda$-conversion into the theory of types
               is impossible if we require that $\lambda$x and juxtaposition
               shall retain their respective meanings as an abstraction
               operator and as denoting the application of function to
               argument. But the present partial incorporation has certain
               advantages from the point of view of type theory and is offered
               as being of interest on this basis (whatever may be thought of
               the finally satisfactory character of the theory of types as a
               foundation for logic and mathematics).For features of the
               formulation which are not immediately connected with the
               incorporation of $\lambda$-conversion, we are heavily indebted
               to Whitehead and Russell, Hilbert and Ackermann, Hilbert and
               Bernays, and to forerunners of these, as the reader familiar
               with the works in question will recognize.The class of type
               symbols is described by the rules that {\i} and o are each type
               symbols and that if $\alpha$ and $\beta$ are type symbols then
               ($\alpha$$\beta$) is a type symbol: it is the least class of
               symbols which contains the symbols {\i} and o and is closed
               under the operation of forming the symbol ($\alpha$$\beta$) from
               the symbols $\alpha$ and $\beta$.},
  journal   = {J. Symb. Log.},
  publisher = {Cambridge University Press (CUP)},
  volume    = 5,
  number    = 2,
  pages     = {56--68},
  month     = jun,
  year      = 1940,
  language  = {en}
}

@inproceedings{MILNER1978,
  title     = {A theory of type polymorphism in programming},
  author    = {Milner, Robin},
  booktitle = {Journal of Computer and System Sciences},
  volume    = {17},
  number    = {3},
  pages     = {348--375},
  year      = {1978},
  publisher = {Elsevier}
}

@phdthesis{DAMAS1982,
  title  = {Principal type-schemes for functional programs},
  author = {Damas, Luis and Milner, Robin},
  year   = {1982},
  school = {University of Edinburgh, Scotland}
}

@phdthesis{DAMAS1984,
  title  = {Type assignment in programming languages},
  author = {Damas, Luis},
  year   = {1984},
  school = {University of Edinburgh}
}

@article{HINDLEY1969,
  title     = {The principal type-scheme of an object in combinatory logic},
  author    = {Hindley, R},
  journal   = {Trans. Am. Math. Soc.},
  publisher = {JSTOR},
  volume    = 146,
  pages     = {29},
  month     = dec,
  year      = 1969
}

@mastersthesis{CASTRO2019,
  author = {Rafael Castro Gonçalves Silva},
  school = {UDESC},
  title  = {Uma Certificação em Coq do Algoritmo W Monádico},
  year   = {2019}
}

@book{MUCHNICK1997,
  title     = {Advanced Compiler Design and Implementation},
  author    = {Muchnick, Steven S},
  publisher = {Morgan Kaufmann},
  month     = sep,
  year      = 1997,
  address   = {Oxford, England}
}

@article{APPEL1997,
  title     = {Shrinking lambda expressions in linear time},
  author    = {Appel, Andrew W and Jim, Trevor},
  abstract  = {Functional-language compilers often perform optimizations based
               on beta and delta reduction. To avoid speculative optimizations
               that can blow up the code size, we might wish to use only
               shrinking reduction rules guaranteed to make the program
               smaller: these include dead-variable elimination, constant
               folding, and a restricted beta rule that inlines only functions
               that are called just once. The restricted beta rule leads to a
               shrinking rewrite system that has not previously been studied.
               We show some efficient normalization algorithms that are
               immediately useful in optimizing compilers; and we give a
               confluence proof for our system, showing that the choice of
               normalization algorithm does not affect final code quality.},
  journal   = {J. Funct. Prog.},
  publisher = {Cambridge University Press (CUP)},
  volume    = 7,
  number    = 5,
  pages     = {515--540},
  month     = sep,
  year      = 1997,
  language  = {en}
}

@phdthesis{CRISTIANO2004,
  author = {Cristiano Damiani Vasconcellos},
  title  = {Inferência de Tipos com Suporte para Sobrecarga Baseada no Sistema CT},
  school = {Universidade Federal de Minas Gerais},
  year   = 2004
}

@inproceedings{RIBEIRO2016,
  author    = {Ribeiro, Rodrigo
               and Camar{\~a}o, Carlos},
  editor    = {Corn{\'e}lio, M{\'a}rcio
               and Roscoe, Bill},
  title     = {A Mechanized Textbook Proof of a Type Unification Algorithm},
  booktitle = {Formal Methods: Foundations and Applications},
  year      = {2016},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {127--141},
  abstract  = {Unification is the core of type inference algorithms for modern functional programming languages, like Haskell. As a first step towards a formalization of a type inference algorithm for such programming languages, we present a formalization in Coq of a type unification algorithm that follows classic algorithms presented in programming language textbooks.},
  isbn      = {978-3-319-29473-5}
}

